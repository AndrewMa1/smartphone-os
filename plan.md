## 智能眼镜控制中台实现计划

### 阶段 0：准备与需求澄清
- **目标理解**：整理三路 USB 摄像头（1 彩色 + 2 红外）实时预览、录制、Web 控制台交互需求。
- **环境调研**：确认开发板系统版本、可用 Python 版本、OpenCV/FFmpeg/GStreamer 支持情况。
- **依赖规划**：锁定 Python Web 框架（建议 `FastAPI` + `uvicorn`）、模板渲染引擎（`Jinja2`）、视频传输方案（MJPEG/WS）。

### 阶段 1：项目初始化
- **代码结构**：在 `smartphone-os` 内创建 `server/` 目录，划分 `backend/`、`frontend/`、`scripts/`。
- **虚拟环境**：创建 Python venv，安装基础依赖（`fastapi`, `uvicorn`, `opencv-python`, `numpy`, `jinja2`, `python-multipart` 等）。
- **基础服务**：搭建 FastAPI 应用骨架和静态文件托管，定义健康检查接口。

### 阶段 2：摄像头抽象层
- **设备管理器**：封装摄像头枚举、打开、关闭逻辑，兼容 CAP_DSHOW / V4L2（需在 Linux 上验证）。
- **帧处理管线**：参考 `usb_camera_reader.py` 构建单例摄像头对象，支持旋转、翻转、分辨率配置。
- **录制模块**：设计可复用的视频文件写入器，支持三路同步创建/关闭。

### 阶段 3：实时视频分发
- **选型确定**：比较 MJPEG over HTTP、WebSocket 帧推送、WebRTC；首版采用 MJPEG 流（实现简单，前端易集成）。
- **实现细节**：
  - 后端生成 MJPEG multipart 响应，按需推送帧。
  - 提供 REST 控制接口：开启/关闭单个摄像头、开始/停止录制。
  - 统一状态管理，防止重复打开或资源泄露。

### 阶段 4：前端控制台
- **UI 原型**：三列摄像头预览窗口 + 顶部状态栏 + 控制面板（按钮/开关）。
- **交互逻辑**：
  - 页面加载时拉取摄像头列表与状态。
  - 通过按钮调用后端接口控制开启/关闭、录制。
  - 在预览区域嵌入 `<img>` 指向 MJPEG 流，动态显示录制状态。
- **视觉优化**：浅色主题、响应式布局、状态提示（例如红点 Recording）。

### 阶段 5：录制与数据存储
- **目录结构**：沿用 `record/<timestamp>/`，每路输出独立文件（`eye0.mp4`, `eye1.mp4`, `world.mp4`）。
- **后台任务**：在录制状态下持续写帧，并暴露 REST API 获取历史记录。
- **异常处理**：录制失败重试、错误反馈到前端。

### 阶段 6：部署与运维
- **服务启动脚本**：提供 systemd service 或自启动脚本，自动拉起 uvicorn。
- **网络配置**：确认 Wi-Fi STA 模式、局域网访问，必要时添加自签证书/反向代理。
- **监控与日志**：输出访问日志、摄像头状态日志，便于调试。

### 阶段 7：测试与验证
- **单元/集成测试**：为设备管理、API 层编写基础测试（可使用 `pytest` + mock）。
- **手动验证**：实际连接眼镜，验证三路预览、录制、打开关闭逻辑。
- **性能评估**：测试帧率、延迟、CPU 占用，定位瓶颈。

### 阶段 8：文档与交付
- **使用说明**：编写 README（安装、运行、常见问题）。
- **维护指南**：补充摄像头型号兼容性、故障排查步骤。
- **下一步规划**：列出功能拓展（例如 WebRTC、数据分析、诊断模块）。